#+TITLE: Emacs Configuration
#+AUTHOR: Nathanael Gentry
#+EMAIL: ngentry1@liberty.edu
#+OPTIONS: toc:nil num:nil
#+PROPERTY: header-args :results output silent

Welcome, dear reader, to the esoteric world of Emacs. I have been spent
countless hours hacking out this configuration since I committed by digital life
to Emacs in May 2019. Configurations are not merely programs; they are personal
commitments -- statements of faith -- value judgments on what matters most in an
editor. Thus, dear reader, please bear with me as I set out my philosophy of
Emacs.

* Prolegomena

I will not explain anew what can be found in the documentation. Consult it early
and often, O Emacs proselyte; you will remain on the straight and narrow road to
Emacs enlightenment.

Functions of my own are prefixed with my initials, and I
have largely maintained prefixes from commands I found elsewhere. As you will
see, I am dearly indebted to [[https://github.com/hrs/dotfiles/blob/master/emacs/.emacs.d/configuration.org][Harry Schwartz]] (=hrs=), [[https://github.com/gjstein/emacs.d][Gregory Stein]] (=gjs=), and
most of all [[http://doc.norang.ca/org-mode.html][Bernt Hansen]] (=bh=) for much of this configuration's groundwork.

This configuration has been developed and tested on Fedora, and it has
Linux-specific dependencies. I have not tested it on Mac.


* Ontology

Ontology (or metaphysics) articulates fundamental relations between the
categories of being. By the light of these objects, we can appreciate the beauty
of our world and contemplate the nature of existence itself.

** Packages

My =init.el= sets up MELPA in the package manager and installs =use-package.el= so all the configuration here works, even on a new install. Here, we make this happen by ensuring packages are installed before we use them.
#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
  (setq package-check-signature nil)
#+end_src


** Outlines

I manage all my work in =org-mode=. Let's ensure we're using the latest released
version with contributions. The included keybindings are fallbacks in case the
=evil= keymaps don't work properly.

I have written [[https://github.com/npjg/org-title-mode][=org-title-mode=]], a little minor-mode for =org-mode=, that changes the buffer name to
the title of the Org document.

#+begin_src emacs-lisp
  (load "/home/npgentry/org/data/a8/e760d1-a2e6-445b-adb5-d6eba2825cb1/org-title-mode/org-title-mode.el")
  (require 'org-title-mode)
#+end_src

Now, we can initialize =org-mode= proper.
#+begin_src emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :init
    (add-hook 'org-mode-hook 'visual-line-mode)
    (add-hook 'org-mode-hook 'org-indent-mode)
    (add-hook 'org-mode-hook 'flyspell-mode)
    (add-hook 'org-mode-hook 'org-title-mode)
    (add-to-list 'org-modules 'org-habit)
    :bind (("\C-c a" . org-agenda)
           ("\C-c c" . org-capture))
    :config
    (setq org-completion-use-ido t
          org-ellipsis " ▼ "))
#+end_src


** Perspectives

In Vanilla Emacs, buffers are shown in windows which are contained in frames. I
did not grasp the power of Emacs until I added a fourth fundamental interface
element: the perspective. There are many window-management libraries out there,
but I appreciated the concision of the [[https://github.com/nex3/perspective-el][=perspective-el=]] library. Perspectives allow
you to switch between named buffer-sets and window configurations; they
essentially let you have multiple frames in just one frame. Since at school I often
must switch between very distinct task sets, perspectives are essential for my
sanity. At all times I strive to have fewer than 10 buffers to worry about in
the given context.

#+begin_src emacs-lisp
  (use-package perspective
    :init
    (setq persp-show-modestring nil
          persp-initial-frame-name "/")
    (persp-mode))
#+end_src

Let's also add functionality to switch /immediately/ to a buffer we add into a
perspective. This should replace the standard =persp-add-buffer=; I can't think
of an interactive use case where I want to add a buffer to a perspective and not
see it right away.

#+begin_src emacs-lisp
  (defun persp-add-and-switch-to-buffer (buffer)
    "Associate BUFFER with the current perspective and switch to it in the current window."
    (interactive
     (list
      (let ((read-buffer-function nil))
        (read-buffer "Add buffer to raise: "))))
    (persp-add-buffer buffer)
    (switch-to-buffer buffer))

  (defun persp-save-some-buffers ()
    "Execute `save-some-buffers' on the current perspective's buffers only."
    (let ((bufs (persp-buffers (persp-curr))))
      (save-some-buffers nil (lambda () (memq (current-buffer) bufs)))))

  (define-key perspective-map (kbd "a") 'persp-add-and-switch-to-buffer)
  (add-hook 'persp-killed-hook #'persp-save-some-buffers)
#+end_src


** Logical Paths

Note that the initial perspective frame name is a single forward slash.
[[https://github.com/npjg/org-perspective][=Org-perspective=]], a library of my own devising, turns my Emacs project index
into a single logical tree, with physical files managed internally by an
extension of the =org-attach= mechanism. Each headline can represent a
perspective with its own attachment directory and a dedicated notes file -- a
special file that continues the logical tree. Eventually, I may split out the
logical-path functionality from the perspective functionality, but the
integration is to my mind so tight I will probably leave it be for some time.

#+begin_src emacs-lisp
  (load "~/org/data/5f/fa1764-3ef8-4477-bc0b-d9ff7455ab13/org-perspective/op.el")
  (require 'org-perspective)
  (setq org-attach-directory "/home/npgentry/org/data")
  (setq org-persp-index "/home/npgentry/org/index.org")
  (op--path-lookup-table nil t)
  (org-persp-path-mode)
#+end_src


I also define some fundamental logical paths that will be used throughout this
configuration.

#+begin_src emacs-lisp
  (setq npg/org-persp-important-paths
        '(:journal "/Journal/Days"
          :courses "/Courses"
          :library "/Library"
          :archive "/Archive"))
#+end_src


** Vim Keybindings

I tried to resist it as long as I could, but I have been converted. Since I am
using =evil-collection= below, we need to prevent =evil= from loading default
keybindings for various modes.

#+BEGIN_SRC emacs-lisp
  (setq evil-want-keybinding nil)
  (use-package evil
    :config
    (evil-mode 1))
#+END_SRC

Because I do not wish to be cast out among the lukewarm, I want to bring good from =evil=
wherever I might -- in many major modes and agendas especially.

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil)

  (use-package evil-org
    :after org
    :config
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda () (evil-org-set-key-theme)))
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src

Even when I walk through the valley of the shadow, Thy parentheses shall console me!

#+begin_src emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
#+end_src


* Logic

What does it profit a man to gain Elisp but lose his efficiency? Let's put good
critical thinking to work for nice utility functions.

** Bric-a-Brac
The doctsrings for these fellows do all the talking.
#+begin_src emacs-lisp
  (defun npg/append-to-path (path)
    "Append a path to $PATH and exec-path"
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))
#+end_src

#+begin_src emacs-lisp
  (defun npg/disable-line-numbers ()
    "Shortcut function to disable line numbers."
    (setq display-line-numbers-mode -1))
#+end_src

#+begin_src emacs-lisp
  (defun npg/buffer-mode (&optional buffer-or-name)
    "Returns the major mode associated with a buffer.
  If buffer-or-name is nil return current buffer's mode."
    (buffer-local-value 'major-mode
                        (if buffer-or-name (get-buffer buffer-or-name) (current-buffer))))
#+end_src


** Peek Frame
Tuhdo has an [[https://tuhdo.github.io/emacs-frame-peek.html][excellent tutorial]] on setting up popup frames for =rtags=, and I've generalized his code and made the popup undecorated but still resizable.

#+begin_src emacs-lisp
  (defun tdh/make-peek-frame (in-frame-function &rest args)
    "Make a new frame for peeking definition"
    (let (summary
          doc-frame
          x y
          ;; Find the pixel absolute position of the current beginning of the symbol at point.
          (abs-pixel-pos (save-excursion
                           (beginning-of-thing 'symbol)
                           (window-absolute-pixel-position))))
      (setq x (car abs-pixel-pos))
      (setq y (+ (cdr abs-pixel-pos) (frame-char-height)))

      ;; 2. Create a new invisible frame, with the current buffer in it.
      (setq doc-frame (make-frame '((minibuffer . nil)
                                    (name . "*Peek*")
                                    (width . 80)
                                    (visibility . nil)
                                    (height . 15)
                                    (undecorated . t)
                                    (drag-internal-border . 1)
                                    (internal-border-width . 5))))

      ;; 3. Position the new frame right under the beginning of the symbol at point.
      (set-frame-position doc-frame x y)

      ;; 4. Jump to the symbol at point.
      (with-selected-frame doc-frame
        (apply in-frame-function args)
        (read-only-mode)
        (when semantic-stickyfunc-mode (semantic-stickyfunc-mode -1))
        (recenter-top-bottom 0))

      ;; 5. Make frame visible again
      (make-frame-visible doc-frame)))
#+end_src


** Transparency
Frame transparency does not seem to play nicely with Cinnamon, but here's a function to manipulate it.
#+begin_src emacs-lisp
  (defun hrs/opacity (value)
    "Sets the percent opacity of the frame window."
    (interactive "nOpacity Value (0 - 100):")
    (set-frame-parameter (selected-frame) 'alpha value))
#+end_src


** Restart Emacs
When I fiddle with my configuration, I will want to restart Emacs often. Let's
use a simple package for this.

#+begin_src elisp
  (use-package restart-emacs)
#+end_src


** Dedicated Windows
See this [[https://emacs.stackexchange.com/questions/2189/how-can-i-prevent-a-command-from-using-specific-windows][Stack Exchange question]].

#+begin_src emacs-lisp
  (defun npg/toggle-window-dedicated ()
    "Control whether or not Emacs is allowed to display another
  buffer in current window."
    (interactive)
    (message
     (if (let (window (get-buffer-window (current-buffer)))
           (set-window-dedicated-p window (not (window-dedicated-p window))))
         "%s: Can't touch this!"
       "%s is up for grabs.")
     (current-buffer)))
#+end_src


** Remove Advice
Quite useful when I am developing.
#+begin_src emacs-lisp
  (defun npg/advice-unadvice (sym)
    "Remove all advices from symbol SYM."
    (interactive "aFunction symbol: ")
    (advice-mapc (lambda (advice _props) (advice-remove sym advice)) sym))
#+end_src


** =Shell-command-to-string= Sensibly

Let's add an option to remove a trailing newline from shell output.

#+begin_src emacs-lisp
  (defun npg/shell-command-to-string (&rest command)
    "Call a shell command with args in COMMAND separated by spaces,
  and remove a trailing newline from the output."
    (replace-regexp-in-string "\n\\'" ""
                              (shell-command-to-string (mapconcat 'identity command " "))))

#+end_src


** Access Keyword Property

Here's a rather clunky interface for getting keyword properties from Org
buffers.

#+begin_src emacs-lisp
  (defun npg/org-buffer-props (property &optional buffer parsed)
    "Get the output of `org-element-parse-buffer' for keyword
  PROPERTY in BUFFER. To save costly parses of the current buffers,
  supply a cached call to `org-elemnet-parse-buffer' in PARSED."
    (with-current-buffer (or buffer (current-buffer))
      (org-element-map
          (or parsed (org-element-parse-buffer)) 'keyword
        (lambda (el) (when (string-match property (org-element-property :key el)) el)))))

  (defun npg/org-buffer-prop (property &optional buffer parsed)
    "Get the value of the keyword PROPERTY in BUFFER. Optionally
  supply a cached buffer parse in PARSED."
    (or (plist-get (cadar (npg/org-buffer-props property buffer parsed)) :value) ""))
#+end_src


** Split Babel Blocks

With this nice solution from [[https://scripter.co/splitting-an-org-block-into-two/][Kaushal Modi]], I can split arbitrary Babel blocks at point -- quite
useful even for editing this configuration.
#+begin_src emacs-lisp
  (defun modi/org-in-any-block-p ()
    "Return non-nil if the point is in any Org block.

  The Org block can be *any*: src, example, verse, etc., even any
  Org Special block.

  This function is heavily adapted from `org-between-regexps-p'."
    (save-match-data
      (let ((pos (point))
            (case-fold-search t)
            (block-begin-re "^[[:blank:]]*#\\+begin_\\(?1:.+?\\)\\(?: .*\\)*$")
            (limit-up (save-excursion (outline-previous-heading)))
            (limit-down (save-excursion (outline-next-heading)))
            beg end)
        (save-excursion
          ;; Point is on a block when on BLOCK-BEGIN-RE or if
          ;; BLOCK-BEGIN-RE can be found before it...
          (and (or (org-in-regexp block-begin-re)
                   (re-search-backward block-begin-re limit-up :noerror))
               (setq beg (match-beginning 0))
               ;; ... and BLOCK-END-RE after it...
               (let ((block-end-re (concat "^[[:blank:]]*#\\+end_"
                                           (match-string-no-properties 1)
                                           "\\( .*\\)*$")))
                 (goto-char (match-end 0))
                 (re-search-forward block-end-re limit-down :noerror))
               (> (setq end (match-end 0)) pos)
               ;; ... without another BLOCK-BEGIN-RE in-between.
               (goto-char (match-beginning 0))
               (not (re-search-backward block-begin-re (1+ beg) :noerror))
               ;; Return value.
               (cons beg end))))))
#+end_src

See, the block splitter works!

#+begin_src emacs-lisp
  (defun modi/org-split-block ()
    "Sensibly split the current Org block at point."
    (interactive)
    (if (modi/org-in-any-block-p)
        (save-match-data
          (save-restriction
            (widen)
            (let ((case-fold-search t)
                  (at-bol (bolp))
                  block-start
                  block-end)
              (save-excursion
                (re-search-backward "^\\(?1:[[:blank:]]*#\\+begin_.+?\\)\\(?: .*\\)*$" nil nil 1)
                (setq block-start (match-string-no-properties 0))
                (setq block-end (replace-regexp-in-string
                                 "begin_" "end_" ;Replaces "begin_" with "end_", "BEGIN_" with "END_"
                                 (match-string-no-properties 1))))
              ;; Go to the end of current line, if not at the BOL
              (unless at-bol
                (end-of-line 1))
              (insert (concat (if at-bol "" "\n")
                              block-end
                              "\n\n"
                              block-start
                              (if at-bol "\n" "")))
              ;; Go to the line before the inserted "#+begin_ .." line
              (beginning-of-line (if at-bol -1 0)))))
      (message "Point is not in an Org block")))
#+end_src

Let's also be able to activate this by a simple =M-RET=.

#+begin_src emacs-lisp
  (defun modi/org-meta-return (&optional arg)
    "Insert a new heading or wrap a region in a table.

  Calls `org-insert-heading', `org-insert-item',
  `org-table-wrap-region', or `modi/org-split-block' depending on
  context.  When called with an argument, unconditionally call
  `org-insert-heading'."
    (interactive "P")
    (org-check-before-invisible-edit 'insert)
    (or (run-hook-with-args-until-success 'org-metareturn-hook)
        (call-interactively (cond (arg #'org-insert-heading)
                                  ((org-at-table-p) #'org-table-wrap-region)
                                  ((org-in-item-p) #'org-insert-item)
                                  ((modi/org-in-any-block-p) #'modi/org-split-block)
                                  (t #'org-insert-heading)))))
  (advice-add 'org-meta-return :override #'modi/org-meta-return)
#+end_src


* Aesthetics

Aesthetics explores beauty and its relation to art. I tend toward a philosophy
of minimalism, and I have sought to remake Emacs in this mold.

** Serenity

I love the unobtrusive elegance of [[https://github.com/arcticicestudio/nord-emacs][nord-emacs]] for working indoors.. Its background hue has such depth it
seems to make my text leap off my screen. I often find myself just staring out
into that lovely cerulean expanse. Yes, sometimes the foreground colors can
be a little /too/ subtle against the profundity of the . Nevertheless, in life I prefer too muted to too stentorian.
#+begin_src emacs-lisp
  (use-package nord-theme
    :load-path "themes"
    :config
    (setq npg/inside-theme 'nord)
    (add-to-list 'custom-safe-themes
                 "82358261c32ebedfee2ca0f87299f74008a2e5ba5c502bde7aaa15db20ee3731")
    (load-theme 'nord t))
#+end_src

Since =nord-theme= doesn't have excellent heading contrast, however, I like to
use pretty bullet heading indicators in =org-mode=.

#+begin_src emacs-lisp
  (use-package org-bullets
    :init (add-hook 'org-mode-hook 'org-bullets-mode))
#+end_src

When I am working barefoot and outdoors, as I often do, a simple high-contrast theme
works best. I chose =dichromacy=.

#+begin_src emacs-lisp
  (defvar npg/outside-theme 'dichromacy)
#+end_src

I want to switch between these themes as quickly as possible. Note that adding
the hash to =custom-safe-theme= above prevents a bothersome prompt each time I
go back inside.

#+begin_src emacs-lisp
  (defun npg/toggle-theme-location ()
    "Easily switch between an inside-friendly and outside-friendly theme."
    (interactive)
    (load-theme (if (memq npg/outside-theme custom-enabled-themes) npg/inside-theme npg/outside-theme)))

  (defun npg/load-theme--disable-old-theme (theme &rest args)
    "Disable current theme completely before loading a new one."
    (mapcar #'disable-theme custom-enabled-themes))

  (advice-add 'load-theme :before #'npg/load-theme--disable-old-theme)
#+end_src


** Sensibility

*** Sensible Defaults

Vanilla Emacs isn't so vanilla. It makes myriad assumptions that I find
enervating, so let's use the [[https://github.com/hrs/sensible-defaults.el/][=sensible-defaults=]] library for common-sense
settings -- such things as inhibiting the startup screen and clearing the
scratch buffer.

#+begin_src emacs-lisp
  (require 'url)
  (setq-local sensible-defaults-loc (concat user-emacs-directory "defaults.el"))
  (if (not (file-exists-p sensible-defaults-loc))
      (url-copy-file "https://raw.githubusercontent.com/hrs/sensible-defaults.el/master/sensible-defaults.el" sensible-defaults-loc))

  (load-file sensible-defaults-loc)
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
#+end_src

Let's also make the default font a bit smaller. The default 13-point font is
just a bit too big for my 1920x1280 display.

#+begin_src emacs-lisp
  (set-frame-font "-PfEd-DejaVu Sans Mono-normal-normal-normal-*-9-*-*-*-m-0-iso10646-1")
#+end_src

Finally, let's enlarge the warning threshold for large files. Loading a 30 MB
HTML file might cause trouble, for instance, but loading a large PDF with
=pdf-view=, what I do far more often, causes no trouble at all.

#+begin_src emacs-lisp
  (setq large-file-warning-threshold 30000000)
#+end_src


*** Viewports

Always kill the current buffer with =C-x k=.

#+begin_src emacs-lisp
  (defun npg/kill-current-buffer ()
    "Kill the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'npg/kill-current-buffer)
#+end_src

When I split a window, I always want focus in the new window.

#+BEGIN_SRC emacs-lisp
  (defun npg/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun npg/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'npg/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'npg/split-window-right-and-switch)
#+END_SRC

I also want a split-window setup when I create a new frame.

#+begin_src emacs-lisp
  (push 'split-window-right after-make-frame-functions)
#+end_src


*** Metatext

Let's make our shallow tabs into spaces.

#+begin_src emacs-lisp
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
#+end_src

I used to display line numbers globally, but that got to be too much of a pain
when I had to picemeal disable numbers for =mu4e=, the agenda, the terminal,
and special modes. Now, we just enable line numbers for major programming
languages -- those that derive from =prog-mode=. This doesn't include LaTeX, but
that's okay.

#+begin_src emacs-lisp
  (dolist (lines-mode
           '(prog-mode-hook))
    (add-hook lines-mode #'display-line-numbers-mode))
#+end_src

Also show column numbers in the modeline.

#+begin_src emacs-lisp
  (setq column-number-mode t)
#+end_src


*** Archive
#+begin_src emacs-lisp
  (setq org-archive-location
        (format "%s::* %%s"
         (org-persp-entry-point (plist-get npg/org-persp-important-paths :archive))))
#+end_src


** Simplicity

I cannot let Emacs to get in the way of my editing.

*** Modeline

I want a pristine modeline, uncluttered by modetexts. Note that the frame title gives =projectile= information.
#+begin_src emacs-lisp
  (use-package minions
    :config
    (setq minions-mode-line-lighter ""
          minions-mode-line-delimiters '("" . ""))
    (minions-mode 1))
#+end_src

Now, let's hide the default system load information and just show 24-hour time
in the modeline.

#+begin_src emacs-lisp
  (setq display-time-default-load-average nil
        display-time-24hr-format t)

  (display-time-mode)
#+end_src


*** Autosave

Add a temporary customization file so any variable customizations we make won't
clutter =init.el=. If I want a customization to stick, I'll put it here.

#+begin_src emacs-lisp
  (setq custom-file (make-temp-file "emacs-custom"))
#+end_src

Perhaps backups would be good to have, but let's not have them clutter our
current directory. Please, no autosave or lockfiles either. Life is too short to
spend cleaning out those. I save frequently enough and don't regularly work in
directly shared directories.

#+begin_src emacs-lisp
  (setq backup-directory-alist '(("" . "~/.emacs.d/backup")))
  (setq auto-save-default nil
        create-lockfiles nil)
#+end_src


*** Display

Reclaim real estate, especially on my beloved ThinkPad X220T, by disabling window chrome and
opening all Emacs frames maximized. I live in it, after all.

#+begin_src emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)

  (toggle-frame-maximized)
  (add-to-list 'default-frame-alist '(fullscreen . fullboth))
#+end_src

When I /do/ run out of space, wrap lines globally, please. (Note that
=auto-fill-mode= in prose environments will obviate the need for this; it's a
backup.)
#+begin_src emacs-lisp
  (global-visual-line-mode)
#+end_src

Tooltips are a nuisance. Let's just display the information in the minibuffer
area instead.

#+begin_src emacs-lisp
  (tooltip-mode -1)
#+end_src

I don't like blinking cursors, especially when I am reading documents in Emacs.

#+begin_src emacs-lisp
  (blink-cursor-mode -1)
#+end_src

Audiovisual indications of errors quite distracting. Can I not just read the
echo area or examine the backtrace when there's a problem?

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore
        visible-bell nil)
#+end_src

For an engineer's mind, the more visual it is, the simpler it is.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src

Let's also dispense with the GNU advertisement when Emacs starts and replace it
with an init time message.

#+begin_src emacs-lisp
  (defun display-startup-echo-area-message ()
    (message "Init Time: %s" (emacs-init-time)))
#+end_src


** Propinquity

I want to have all my functionality close at hand, closer than a friend.

*** Completion

In keeping with my minimalist outlook, I have chosen =ivy= and =counsel= as my
completion framework.

This configuration uses =counsel-M-x= for command completion, replaces =isearch=
with =swiper=, uses =smex= to maintain history, enables fuzzy matching
everywhere except swiper (where it's thoroughly unhelpful), and ncludes recent
files in the switch buffer.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :bind
    ("M-x" . 'counsel-M-x)
    ("C-s" . 'swiper)

    :config
    (use-package flx)
    (use-package smex)

    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy))))
#+END_SRC

=Ido-mode= also fits well with my aesthetic. I see no need to go to Helm right
now. I can be the master of my own ship.

#+begin_src emacs-lisp
  (ido-mode 'both)
  (setq ido-enable-flex-matching t)

                                          ; Use the current window when visiting files and buffers with ido
  (setq ido-default-file-method 'selected-window)
  (setq ido-default-buffer-method 'selected-window)

                                          ; Use the current window for indirect buffer display
  (setq org-indirect-buffer-display 'current-window)
#+end_src


*** Global Keymaps

I never use the paging keys in buffers; they lose too much context, and I can
easily scroll with my TrackPoint. Thus, let's use these keys to quickly switch windows.

#+begin_src emacs-lisp
  (global-set-key (kbd "<prior>") 'other-window)
#+end_src

=Which-key= also proves immensely helpful for my forgetful mind.

#+begin_src emacs-lisp
  (use-package which-key
    :init
    (which-key-mode)
    (setq which-key-idle-delay 0.2)

    :diminish which-key-mode)
#+end_src

And here are my global keybindings, which play off the =<SUPER>= (Windows) key.

#+begin_src emacs-lisp
  (define-key global-map (kbd "s-p") 'bh/punch-in)
  (define-key global-map (kbd "s-[") 'bh/punch-out)
  (define-key global-map (kbd "s-'") 'org-capture)
  (define-key global-map (kbd "s-\\") 'npg/find-function)
  (define-key global-map (kbd "s-;") 'org-persp-launch)
  (define-key global-map (kbd "s-0") 'npg/toggle-theme-location)
  (define-key global-map (kbd "s-x") 'persp-switch)
  (define-key global-map (kbd "s-z") 'persp-kill)
  (define-key global-map (kbd "s-r") 'npg/counsel-rhythmbox)
  (define-key global-map (kbd "s-o") 'org-attach-open)
#+end_src

We create a prefix-argument version of =find-function=, useful for window management.

#+begin_src emacs-lisp
  (defun npg/find-function (arg)
    (interactive "P")
    (if arg (call-interactively #'find-function-other-window) (call-interactively #'find-function)))
#+end_src


* Ethics

Let's use Emacs the right way. When you're on the right path, life becomes so
much easier. These packages are normative; one ought not to use Emacs without them.

** Smartparens
So powerful.

#+begin_src emacs-lisp
  (use-package smartparens
    :bind (:map smartparens-mode-map
                ("C-M-f" . sp-next-sexp)
                ("C-M-b" . sp-backward-sexp)
                ("C-M-d" . sp-down-sexp)
                ("C-M-a" . sp-backward-down-sexp)
                ("C-M-u" . sp-up-sexp)
                ("C-M-e" . sp-backward-up-sexp)
                ("C-M-n" . sp-forward-sexp)
                ("C-M-p" . sp-previous-sexp)
                ("C-S-d" . sp-beginning-of-sexp)
                ("C-S-a" . sp-end-of-sexp)
                ("C-M-k" . sp-kill-sexp)
                ("C-M-w" . sp-copy-sexp)
                ("M-<delete>" . sp-unwrap-sexp)
                ("M-<backspace>" . sp-backward-unwrap-sexp)
                ("M-D" . sp-splice-sexp)
                ("C-S-<backspace>" . sp-splice-sexp-killing-around)
                ("C-<right>" . sp-forward-slurp-sexp)
                ("C-<left>" . sp-forward-barf-sexp)
                ("C-S-<left>" . sp-backward-slurp-sexp)
                ("C-S-<right>" . sp-backward-barf-sexp))
    :init
    (setq sp-cancel-autoskip-on-backward-movement nil)

    :config
    (require 'smartparens-config))

  (use-package evil-smartparens
    :after smartparens)
#+end_src


** Yasnippet

I really haven't begun using snippets as much as I should. There are so many
ways in which I am not yet one with the editor.

#+begin_src emacs-lisp
  (use-package yasnippet
    :init (yas-global-mode 1))
#+end_src


** Bookmark+

Since we don't have access to EmacsWiki packages via MELPA anymore, let's just
install this one directly.

#+begin_src emacs-lisp
  (let ((bookmarkplus-dir (expand-file-name "bookmark-plus/" user-emacs-directory))
        (emacswiki-base "https://www.emacswiki.org/emacs/download/")
        (bookmark-files '("bookmark+.el" "bookmark+-mac.el" "bookmark+-bmu.el" "bookmark+-key.el" "bookmark+-lit.el" "bookmark+-1.el")))
    (require 'url)
    (add-to-list 'load-path bookmarkplus-dir)
    (make-directory bookmarkplus-dir t)
    (mapcar (lambda (arg)
              (let ((local-file (concat bookmarkplus-dir arg)))
                (unless (file-exists-p local-file)
                  (url-copy-file (concat emacswiki-base arg) local-file t))))
            bookmark-files)
    (byte-recompile-directory bookmarkplus-dir 0)
    (require 'bookmark+))
#+end_src


** Company

Enable =company= everywhere, and reward my laziness by giving myself access
to Unicode math.

#+begin_src emacs-lisp
  (use-package company
    :ensure company-math
    :init (global-company-mode 1)
    :config (add-to-list 'company-backends 'company-math-symbols-unicode))
#+end_src

Bind =M-/= to bring up a completion menu.

#+begin_src emacs-lisp
  (global-set-key (kbd "M-/") 'company-complete-common)
#+end_src

Quickhelp is useful for API discovery, but it doesn't talk to =nord-theme= right
now.

#+begin_src emacs-lisp
  (use-package company-quickhelp
    :init (company-quickhelp-mode))
#+end_src


** Flycheck

We'll add local mode hooks for =flycheck= when we get to them.

#+begin_src emacs-lisp
  (use-package flycheck)
#+end_src


** Magit

I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- Use =evil= keybindings with =magit=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- On the command line I'll generally push a new branch with a plain old =git
  push=, which automatically creates a tracking branch on (usually) =origin=.
  Magit, by default, wants me to manually specify an upstream branch. This binds
  =P P= to =magit-push-implicitly=, which is just a wrapper around =git push
  -v=. Convenient!
- I'd like to start in the insert state when writing a commit message.
-
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)

    :config
    (use-package evil-magit)
    (use-package with-editor)
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)

    (with-eval-after-load 'magit-remote
      (magit-define-popup-action 'magit-push-popup ?P
        'magit-push-implicitly--desc
        'magit-push-implicitly ?p t))

    (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC


** Silver Searcher
Try out =ag=.
#+begin_src emacs-lisp
  (use-package ag)
#+end_src


** Projectile

Search for files within a project with =projectile-ag= through =C-c v=. Also
bind =C-p= to fuzzy-searching within a project, and use the current directory as
a project root when we don't have a defined project. This enables
fuzzy-searching for files anywhere.

#+begin_src emacs-lisp
  (use-package projectile
    :bind
    ("C-c v" . 'projectile-ag)

    :config
    (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion ag-mode-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'projectile-find-file)

    (setq projectile-completion-system 'ivy
          projectile-switch-project-action 'projectile-dired
          projectile-require-project-root nil))
#+end_src


** Dumb Jump
And to think of the untold hours I spent configuring C\C++ tags when I could have used this!
#+begin_src emacs-lisp
  (use-package dumb-jump
    :config
    (define-key evil-normal-state-map (kbd "M-.") 'dumb-jump-go)
    (setq dumb-jump-selector 'ivy))
#+end_src



* Epistemology

What do we know? How do we know it? What does knowing mean, anyway? These are
the questions of epistemology. Here, Emacs gains knowledge of the major modes
and input methods I frequent.

First, though, let's ensure my Emacs knows who its master is.

#+begin_src emacs-lisp
  (setq user-full-name "Nathanael Gentry"
        user-mail-address "ngentry1@liberty.edu")
#+end_src

** Terminal
Use =multi-term= for login shell sessions. (If we only really want to have one
terminal open at a time, should we really be using =multi-term=?)

#+begin_src emacs-lisp
  (use-package multi-term
    :init
    (global-set-key (kbd "C-c T") 'multi-term)
    (global-set-key (kbd "C-c t") 'multi-term-dedicated-open)
    (setq multi-term-program-switches "--login"
          multi-term-switch-after-close nil
          multi-term-dedicated-select-after-open-p t))
#+end_src

Let's not use =evil= in the terminal. It's distracting, and it rebinds some useful
keys, like =C-d=.

#+begin_src emacs-lisp
  (evil-set-initial-state 'term-mode 'emacs)
#+end_src


** Prose

*** Dictionary

I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
so these definitions are a lot of fun.

#+begin_src emacs-lisp
  (defun hrs/region-or-word ()
    (if mark-active
        (buffer-substring-no-properties (region-beginning)
                                        (region-end))
      (thing-at-point 'word)))

  (defun hrs/dictionary-prompt ()
    (read-string
     (format "Word (%s): " (or (hrs/region-or-word) ""))
     nil
     nil
     (hrs/region-or-word)))

  (defun hrs/dictionary-define-word ()
    (interactive)
    (let* ((word (hrs/dictionary-prompt))
           (buffer-name (concat "Definition: " word)))
      (split-window-below)
      (with-output-to-temp-buffer buffer-name
        (shell-command (format "sdcv -n %s" word) buffer-name))))

  (define-key global-map (kbd "s-w") 'hrs/dictionary-define-word)
#+end_src

*** Thesaurus

Synosaurus is hooked up to wordnet to provide access to a thesaurus. Hitting
=C-x s= searches for synonyms.

#+BEGIN_SRC emacs-lisp
  (use-package synosaurus)
  (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
  (add-hook 'after-init-hook #'synosaurus-mode)
  (define-key global-map (kbd "s-S") 'synosaurus-lookup)
#+END_SRC

*** Spelling

Let's enable spell-checking for text (org, markdown) and commit messages.

#+begin_src emacs-lisp
  (use-package flyspell
    :config
    (add-hook 'text-mode-hook 'turn-on-auto-fill)
    (add-hook 'gfm-mode-hook 'flyspell-mode)
    (add-hook 'org-mode-hook 'flyspell-mode)
    (add-hook 'git-commit-mode-hook 'flyspell-mode))
#+end_src

Why would I deal with GUI menus when I can use =ivy=?
#+begin_src emacs-lisp
  (use-package flyspell-correct-ivy
    :bind ("C-M-;" . flyspell-correct-wrapper)
    :init
    (setq flyspell-correct-interface #'flyspell-correct-ivy))
#+end_src

*** Citations

I don't know what did when I had to manage citations manually! =Org-ref= is a
most lovely package. Note how I use an =org-perspective= function to find the
internal path of my library directory. As we will see later, I can add books to
my reading list via ISBN and do other neat automation with =org-ref=.

#+begin_src emacs-lisp
  (let ((library-directory (org-persp-entry-point "/Library" :directory-only)))
    (use-package org-ref
      :init
      (setq reftex-default-bibliography (list (expand-file-name "library.bib" library-directory))
            org-ref-default-bibliography reftex-default-bibliography
            org-ref-pdf-directory (list (file-name-as-directory (expand-file-name "org-ref" library-directory)))
            org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))))
#+end_src

*** Русcкий язык

Cделайте Америка великого снова, товарищи!

#+begin_src emacs-lisp
  (setq default-input-method 'russian-computer)
#+end_src


** PDF

Let's initialize =pdf-tools= for full document previews. I read lots of LaTeX
within Emacs.

#+begin_src emacs-lisp
  (use-package pdf-tools
    :bind
    ("C-c C-g" . pdf-sync-forward-search)

    :init
    (pdf-tools-install)
    (setq mouse-wheel-follow-mouse t
          pdf-view-resize-factor 1.00))
#+end_src

I don't like not being able to see whole pages at a time, and fitting the page
to the window also resizes with the window, which I like a lot.

#+begin_src emacs-lisp
  (add-hook 'pdf-view-mode-hook #'pdf-view-fit-page-to-window)
#+end_src

When I am compiling LaTeX or LilyPond, I don't want to wait around for
=global-auto-revert-mode= to pick up the changes; this wastes precious seconds
on every compile, and I perhaps compile more frequently than I should. Even when
the compilation is fast, using an on-demand reversion function, with =pdf-tools=
the window blanks for a moment, which is quite undesirable. Let's do away
entirely with auto-reverting PDFs.

#+begin_src emacs-lisp
  (add-to-list 'global-auto-revert-ignore-modes 'pdf-view-mode)
#+end_src

I like to view PDFs with the background color the same as the current theme. We
use =nord0= and =nord4=, since I spend most of my time indoors. With these
colors, the cursor is visible, so we want to hide it in PDFView buffers.

#+begin_src emacs-lisp
  (setq pdf-view-midnight-colors '("#d8dee9" . "#2e3440"))
  (add-hook 'pdf-view-mode-hook #'pdf-view-midnight-minor-mode)
#+end_src

=evil= will sometimes conflict with PDFView, for instance causing a blinking
cursor on the page border. This should have been fixed in PDFView, but I make sure it
doesn't happen. But first, let's define helper functions so we don't have
lambdas in hooks.

#+begin_src emacs-lisp
  (defun npg/disable-evil-emacs-state-cursor ()
    (set (make-local-variable 'evil-emacs-state-cursor) (list nil)))

  (evil-set-initial-state 'pdf-view-mode 'emacs)
  (add-hook 'pdf-view-mode-hook #'npg/disable-evil-emacs-state-cursor)
#+end_src

I cannot use =swiper= in PDFView buffers, so let's use the provided minor mode
to do plain old Isearch. Let's also get back some basic =evil= functionality.

#+begin_src emacs-lisp
  (define-key pdf-view-mode-map "j" 'pdf-view-next-line-or-next-page)
  (define-key pdf-view-mode-map "k" 'pdf-view-previous-line-or-previous-page)
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward-regexp)
#+end_src


** LaTeX

Now, we can setup LaTeX. I don't bother setting up RefTeX because I write papers in Org.
Note, however, that Org also uses these settings to show PDF previews.

#+begin_src emacs-lisp
  (use-package tex-site
    :ensure auctex
    :init
    (setq TeX-auto-save t
          TeX-save-query nil
          TeX-parse-self t
          TeX-source-correlate-method 'synctex
          TeX-correlate-start-server t
          TeX-view-program-selection '((output-pdf "pdf-tools"))
          TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))
    (add-hook 'LaTeX-mode-hook
              #'yas-minor-mode)
    (add-hook 'LaTeX-mode-hook
              #'outline-minor-mode)
    (add-hook 'LaTeX-mode-hook
              #'outline-next-heading))
#+end_src

Next, let's hook in the fast reversion function. We will only
revert the PDF buffer when compilation succeeds, and we want to display an error
buffer in the same window when there are any errors.

#+begin_src emacs-lisp
  (defun npg/TeX-revert-document-buffer (file)
    (unless (TeX-error-report-has-errors-p)
      (TeX-revert-document-buffer file)))

  (add-hook 'TeX-after-compilation-finished-functions
            #'TeX-revert-document-buffer)
#+end_src

Let's only show the error output when we have a compile problem. We have a
nicely-formatted report in the window where the PDF would go when we encounter
errors.

#+begin_src emacs-lisp
  (setq TeX-error-overview-open-after-TeX-run t)
#+end_src

Let's also not keep an =./auto= directory in every single source file directory.

#+begin_src emacs-lisp
    (setq-default TeX-auto-local
     (expand-file-name "auctex-auto" (npg/shell-command-to-string "mktemp" "-d")))
#+end_src

Let's attempt to use =texcount= instead of the default word counter whenever we
are editing LaTeX. I don't need strict word counts in pure LaTeX often, and integrating
=texcount= to =org-mode= would be much more useful.

#+begin_src emacs-lisp
  (defun npg/texcount-words ()
    "Run `texcount' on the current file."
    (interactive)
    (save-buffer)
    (let* ((this-file (buffer-file-name))
           (enc-str (symbol-name buffer-file-coding-system))
           (enc-opt (cond ((string-match "utf-8" enc-str) "-utf8")
                          ((string-match "latin" enc-str) "-latin1")
                          ("-encoding=guess")))
           (word-count (shell-command-to-string
                        (npg/join " " "texcount"  "-0" enc-opt this-file))))
      (message word-count)))

  (add-hook 'LaTeX-mode-hook (lambda () (define-key LaTeX-mode-map "\M-=" 'npg/texcount-words)))
  (add-hook 'latex-mode-hook (lambda () (define-key latex-mode-map "\M-=" 'npg/texcount-words)))
#+end_src

Let's also specify places where we don't want auto-fill mode to operate inside a
LaTeX environment. There's nothing more irritating than a complex equation
wrapping where you don't want. Given how many math environments versus text
environments I use, though, it might be better to use a whitelist instead of a
blacklist.

#+begin_src emacs-lisp
  (defvar npg/LaTeX-no-autofill-environments
    '("equation" "equation*" "align" "align*" "tikzpicture")
    "A list of LaTeX environment names in which `auto-fill-mode' should be inhibited.")

  (defun npg/LaTeX-auto-fill-function ()
    "This function checks whether point is currently inside one of
  the LaTeX environments listed in
  `npg/LaTeX-no-autofill-environments'. If so, it inhibits automatic
  filling of the current paragraph."
    (let ((do-auto-fill t)
          (current-environment "")
          (level 0))
      (while (and do-auto-fill (not (string= current-environment "document")))
        (setq level (1+ level)
              current-environment (LaTeX-current-environment level)
              do-auto-fill (not (member current-environment npg/LaTeX-no-autofill-environments))))
      (when do-auto-fill
        (do-auto-fill))))

  (defun npg/LaTeX-setup-auto-fill ()
    "This function turns on auto-fill-mode and sets the function
  used to fill a paragraph to `npg/LaTeX-auto-fill-function'."
    (auto-fill-mode)
    (setq auto-fill-function 'npg/LaTeX-auto-fill-function))

  (add-hook 'LaTeX-mode-hook 'npg/LaTeX-setup-auto-fill)
#+end_src


** WWW

Since we're just using =eww= to peruse static content with admittedly small type, it would
be great to highlight the current line.

#+begin_src emacs-lisp
  (add-hook 'eww-mode-hook 'hl-line-mode)
#+end_src

Let's enable opening more than one =eww= buffer by generating a unique buffer
name for each page. Note the utility of Bookmark+ here.

#+begin_src emacs-lisp
  (setq bmkp-eww-buffer-renaming 'url)
#+end_src


** COMMENT Email

*** System
I will connect =mu4e= to =offlineimap=, which I install in my environment documentation.
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
  (require 'mu4e)
#+end_src

I like to think of my mail as living in a Postoffice rather than a Maildir. Perhaps it's just the Brit in me.
#+begin_src emacs-lisp
  (setq mu4e-maildir "~/postoffice")
#+end_src

By officially registering =mu4e= here, we can start a message with =C-x m=.
#+begin_src emacs-lisp
  (setq mail-user-agent 'mu4e-user-agent)
#+end_src

Rather than installing an =offlineimap= timer in =systemctl=, let's have =mu4e=
call one-off updates every five for us by its own timer. I haven't yet investigated the relative performance implications.
#+begin_src emacs-lisp
  (setq mu4e-get-mail-command "offlineimap -o"
        mu4e-update-interval 300)
#+end_src

Use =evil= bindings for navigation.
#+begin_src emacs-lisp
  (use-package evil-mu4e)
  (require 'evil-mu4e)
#+end_src

Don't ask us about quitting =mu4e=.
#+begin_src emacs-lisp
  (setq mu4e-confirm-quit nil)
#+end_src

*** Contexts
See the [[file:~/.offlineimaprc][OfflineIMAP Config]] for inbound mail.

We send all messages by SMTP.
#+begin_src emacs-lisp
  (setq message-send-mail-function 'smtpmail-send-it)
#+end_src

**** Exchange
#+begin_src emacs-lisp
  (let ((exchange-setup-vars '((smtpmail-smtp-server  . "localhost")
                               (smtpmail-smtp-service . 1025)
                               (smtpmail-stream-type  . network)
                               (mu4e-maildir-shortcuts . (("/Exchange/INBOX" . ?i)
                                                          ("/Exchange/Sent" . ?s)
                                                          ("/Exchange/Trash" . ?t)))))
        (exchange-sent-folder "Sent")
        (exchange-trash-folder "Trash")
        (exchange-refile-folder "Archive")
        (exchange-drafts-folder "Drafts"))

    (make-mu4e-context-account
     :name "Exchange"
     :user-mail-address npg/exchange-address
     :sent-folder exchange-sent-folder
     :trash-folder exchange-trash-folder
     :drafts-folder exchange-drafts-folder
     :refile-folder exchange-refile-folder
     :vars exchange-setup-vars))
#+end_src

**** Gmail
#+begin_src emacs-lisp
  (let ((gmail-setup-vars '((smtpmail-smtp-server   . "smtp.gmail.com")
                            (smtpmail-stream-type   . starttls)
                            (smtpmail-smtp-service  .  587)
                            (mu4e-maildir-shortcuts . (("/Gmail/INBOX" . ?i)
                                                       ("/Gmail/[Gmail].Sent Mail"   . ?s)
                                                       ("/Gmail/[Gmail].Trash"       . ?t)))))
        (gmail-prefix "[Gmail].")
        (gmail-sent-folder "Sent Mail")
        (gmail-trash-folder "Trash")
        (gmail-drafts-folder "Drafts"))

    (make-mu4e-context-account
     :name "Gmail"
     :user-mail-address npg/gmail-address
     :sent-folder (concat gmail-prefix gmail-sent-folder)
     :trash-folder (concat gmail-prefix gmail-trash-folder)
     :drafts-folder (concat gmail-prefix gmail-drafts-folder)
     :vars gmail-setup-vars))
#+end_src

*** Headers
Only move messages to the trash folder; do not mark them as deleted.
In other words, do not add =+T= before =-N= so message is not marked IMAP-deleted. See [[https://github.com/djcb/mu/issues/1136][mu #1136]].
#+begin_src emacs-lisp
  (setf (alist-get 'trash mu4e-marks)
        (list :char '("d" . "▼")
              :prompt "dtrash"
              :dyn-target (lambda (target msg)
                            (mu4e-get-trash-folder msg))
              :action (lambda (docid msg target)
                        (mu4e~proc-move docid (mu4e~mark-check-target target) "-N"))))
#+end_src

Optimize display for split window; do not reproduce the subject line within threads.
#+begin_src emacs-lisp
  (setq mu4e-headers-fields
        '( (:human-date     .  25)
           (:flags          .   4)
           (:from           .  22)
           (:thread-subject .  nil)))
#+end_src

Inside the header view, refresh with =o=.
#+begin_src emacs-lisp
  (define-key mu4e-headers-mode-map (kbd "o") 'mu4e-update-mail-and-index)
#+end_src

Quit =mu4e= immediately from header view with =z=.
#+begin_src emacs-lisp
  (define-key mu4e-headers-mode-map (kbd "z") 'mu4e-quit)
#+end_src

*** Composition
Auto-fill mode, which automatically inserts hard linebreaks, is quite unhelpful for messages that will be seen on other clients. Let's use soft breaks instead, so we don't drive our non-Emacs friends crazy.
#+begin_src emacs-lisp
  (add-hook 'mu4e-compose-mode-hook (lambda ()
                                      (auto-fill-mode -1)
                                      (visual-line-mode)))
#+end_src

When I'm composing a new email, default to using the first context (Exchange).
#+BEGIN_SRC emacs-lisp
  (setq mu4e-compose-context-policy 'pick-first)
#+END_SRC

Enable Org-style tables and list manipulation.
#+BEGIN_SRC emacs-lisp
  (add-hook 'message-mode-hook 'turn-on-orgtbl)
  (add-hook 'message-mode-hook 'turn-on-orgstruct++)
#+END_SRC

Once I've sent a message, kill the associated buffer instead of just burying it.
#+BEGIN_SRC emacs-lisp
  (setq message-kill-buffer-on-exit t)
#+END_SRC

*** Replies
So replies quote correctly on other clients, change the reply header string to imitate Gmail.
#+begin_src emacs-lisp
  (defun npg/message-insert-compatible-citation-line ()
    "Based off `message-insert-citation-line`."
    (when message-reply-headers
      (insert "On " (mail-header-date message-reply-headers) " ")
      (insert (mail-header-from message-reply-headers) " wrote...")
      (newline)
      (newline)))

  (setq message-citation-line-function 'npg/message-insert-compatible-citation-line)
#+end_src

*** Reader
While HTML emails are undeniably sinful, we often have to read them. That's
sometimes best done in a browser. This effectively binds =a h= to open the
current email in my default Web browser.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'mu4e-view-actions '("html in browser" . mu4e-action-view-in-browser) t)
#+END_SRC

*** Signatures
These are my plain-text email signatures.
#+begin_src emacs-lisp
  (defvar npg/email-signatures)
  (setq npg/email-signatures '(("formal" . (concat
                                            "Nathanael Gentry\n"
                                            "Mathematics, Liberty University\n"
                                            "Class of 2021\n"))
                               ("personal" . "Nathanael Gentry\n")))
#+end_src

Thanks to Rob Stewart for the =mu4e-read-option= idea.
#+begin_src emacs-lisp
  (defun npg/mu4e-choose-signature ()
    "Insert one of a number of sigs"
    (interactive)
    (let ((message-signature
           (mu4e-read-option "Signature:"
                             npg/email-signatures)))
      (message-insert-signature)))

  (add-hook 'mu4e-compose-mode-hook
            (lambda () (local-set-key (kbd "C-c C-w") #'npg/mu4e-choose-signature)))
#+end_src

*** Notifications
We use the =mu4e-alert= package to give modeline mail alerts, only for the
folders that we care about.
#+begin_src emacs-lisp
  (use-package mu4e-alert
    :after mu4e
    :init
    (setq mu4e-alert-interesting-mail-query
          (concat
           "flag:unread maildir:/Exchange/INBOX "
           "OR "
           "flag:unread maildir:/Gmail/INBOX"))
    (mu4e-alert-enable-mode-line-display)
#+end_src

Refresh the indicator every 360 seconds, or six minutes.
#+begin_src emacs-lisp
  (defun npg/refresh-mu4e-alert-mode-line ()
    (interactive)
    (mu4e-alert-enable-mode-line-display))

  (run-with-timer 0 300 'npg/refresh-mu4e-alert-mode-line))
#+end_src

*** Org
If we capture a todo while in =mu4e= header mode, we should store a link
to the message itself, not the header query.

As noted at [[http://pragmaticemacs.com/emacs/master-your-inbox-with-mu4e-and-org-mode/][Pragmatic Emacs]], this allows creating a todo for messages
that need action, and then archiving it since it no longer needs to stay
in the inbox -- we have a direct link to it in the todo.
#+begin_src emacs-lisp
  (require 'org-mu4e)
  (setq org-mu4e-link-query-in-headers-mode nil)
#+end_src


** Rhythmbox
Let's access the Rhythmbox queue from a =counsel= minibuffer.

#+begin_src emacs-lisp
  (use-package helm-rhythmbox)

  (defun npg/counsel-rhythmbox-enqueue-song (song)
    "Let Rhythmbox enqueue SONG, encoded as a cons cell."
    (let ((service "org.gnome.Rhythmbox3")
          (path "/org/gnome/Rhythmbox3/PlayQueue")
          (interface "org.gnome.Rhythmbox3.PlayQueue"))
      (dbus-call-method :session service path interface
                        "AddToQueue" (helm-rhythmbox-song-uri (cdr song)))))

  (defun npg/counsel-rhythmbox-play-song (song)
    "A wrapper for the new version of `helm-rhythmbox.'"
    (helm-rhythmbox-play-song (cdr song)))

  (defun npg/counsel-rhythmbox ()
    "Choose a song from the Rhythmbox library to play or enqueue."
    (interactive)
    (unless (bound-and-true-p helm-rhythmbox--cache)
      (helm-rhythmbox-load-library))
    (message "%s" (ivy-read "Rhythmbox: "
                            helm-rhythmbox--cache
                            :action
                            '(1 ("Play song" npg/counsel-rhythmbox-play-song)
                                ("Enqueue song" npg/counsel-rhythmbox-enqueue-song)))))
#+end_src


** Finances

Let's try out =ledger-mode= for a while, for keeping track of finances.

#+begin_src emacs-lisp
  (use-package ledger-mode
    :ensure t
    :init
    (setq ledger-clear-whole-transactions 1)

    :config
    (add-to-list 'evil-emacs-state-modes 'ledger-report-mode)
    (setq ledger-report-use-native-highlighting nil)
    :mode "\\.ledger\\'")
#+end_src


** Python

Set up our =virtualenv= for =jedi=.

#+begin_src emacs-lisp
  (npg/append-to-path "~/.local/bin")
#+end_src

Use =elpy= for a great IDE experience.

#+begin_src emacs-lisp
  (use-package elpy
    :init (elpy-enable))
#+end_src

Check syntax with =flycheck=.

#+begin_src emacs-lisp
  (add-hook 'elpy-mode-hook 'flycheck-mode)
#+end_src

Format code by PEP8 on save.

#+begin_src emacs-lisp
  (use-package py-autopep8
    :init (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
#+end_src


** C/C++

I have honestly done very little C development in Emacs. Perhaps I still have a
bad taste in my mouth from the excruciatingly long delays I had setting up even
this in my first Emacs summer. I followed Tuhdo's comprehensive [[https://tuhdo.github.io/c-ide.html][tutorial]].

Maybe =rtags= is a bit intense, but using it with =cmake-ide= works well now.

#+begin_src emacs-lisp
  (use-package rtags
    :ensure flycheck-rtags
    :init
    (add-hook 'c-mode-common-hook (lambda ()
                                    (flycheck-select-checker 'rtags)
                                    (setq-local flycheck-highlighting-mode nil)
                                    (setq-local flycheck-check-syntax-automatically nil)))

    (setq rtags-autostart-diagnostics t
          rtags-completions-enabled t)
    (push 'company-rtags company-backends))
#+end_src

Use =cmake-ide= to automate =rtags= processes in a CMake project.

#+begin_src emacs-lisp
  (use-package cmake-ide
    :init (cmake-ide-setup))
#+end_src


** JSON
=json-mode= works well for all I need, and I have a custom yasnippet for Org. We can pretty-print with =C-c C-f=.
#+begin_src emacs-lisp
  (use-package json-mode)
#+end_src


** XML
nXML modes don't seem to come with a formatter, so let's [[http://blog.bookworm.at/2007/03/pretty-print-xml-with-emacs.html][use one]] from Benjamin
Ferrari's excellent blog.
#+begin_src emacs-lisp
  (defun bf/format-xml-region (begin end)
    "Pretty format XML markup in region. You need to have nxml-mode
  http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do
  this.  The function inserts linebreaks to separate tags that have
  nothing but whitespace between them.  It then indents the markup
  by using nxml's indentation rules."
    (interactive "r")
    (save-excursion
      (nxml-mode)
      (goto-char begin)
      (while (search-forward-regexp "\>[ \\t]*\<" nil t)
        (backward-char) (insert "\n"))
      (indent-region begin end))
    (message "nXML formatted"))
#+end_src

And let's bind the key in nXML mode; we need to standardize a formatting key
anyhow.
#+begin_src emacs-lisp
  (general-define-key
   :keymaps 'nxml-mode-map
   :states '(normal motion)
   "C-c C-r f" '(bf/format-xml-region :which-key "format region"))
#+end_src


** YAML
#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src



** Org

*** Edit & Export

Indent headings by default, and use =yasnippet= with LaTeX snippets available.

#+begin_src emacs-lisp
  (dolist (mode-hook '(org-indent-mode yas-minor-mode))
    (add-hook 'org-mode-hook mode-hook))
  (yas-activate-extra-mode 'latex-mode)
#+end_src

Enable LaTeX snippet highlighting.

#+begin_src emacs-lisp
  (setq org-highlight-latex-and-related '(latex script entities))
#+end_src

I write papers to strict word counts in Org mode, and this [[https://orgmode.org/worg/org-hacks.html#org37fcf22][hack]] gives us almost
a pure count of the prose in the document. It's wrapped nicely in =org-wc=.

#+begin_src emacs-lisp
  (use-package org-wc
    :config
    (setq org-wc-default-link-count 'description)
    (setq org-wc-ignored-link-types
          (append org-wc-ignored-link-types '(fn cite autocite))))
#+end_src

Open source block editor (=C-c '=) in a lower window; make formats and tabs
native.

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-src-window-setup 'split-window-below)
#+end_src

Include these source block identifiers:

#+begin_src emacs-lisp
  (add-to-list 'org-src-lang-modes '("json" . json))
#+end_src

Allow =babel= to evaluate the following languages:

#+BEGIN_SRC emacs-lisp
  (use-package gnuplot)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (C . t)
     (lilypond . t)
     (python . t)
     (shell . t)
     (dot . t)
     (gnuplot . t)))
#+END_SRC

Don't ask before evaluating code blocks.

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

Allow export to Markdown and LaTeX Beamer.

#+BEGIN_SRC emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+END_SRC

Also enable Lilypond export

#+begin_src emacs-lisp
  (require 'ob-lilypond)
#+end_src

Generate a custom export class for Turabian papers. (Yes, I did study philosophy
at one point.)

#+begin_src emacs-lisp
  (add-to-list 'org-latex-classes
               '("turabian"
                 "\\documentclass{turabian-researchpaper}"
                 ("\\part{%s}" . "\\part*{%s}")
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
               )
#+end_src

Make sure we have the latest version of =htmlize= installed by default.

#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+BEGIN_SRC emacs-lisp
  (setq org-html-postamble nil)
#+END_SRC

Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
which checks the =$BROWSER= environment variable to choose the right browser.
I'd like to always use Firefox, so:

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "firefox")

  (setq proess-connection-type nil)
#+END_SRC


*** Calendar

Configure =org-caldav= package to point toward my ownCloud instance and main
calendar.

#+begin_src emacs-lisp
  (let ((pom (op--physical-location "/Calendar" :enter)))
    (use-package org-caldav
      :init
      (setq org-caldav-url (npg/org-buffer-prop "REMOTE_URL" (marker-buffer pom))
            org-caldav-calendar-id (npg/org-buffer-prop "REMOTE_ID" (marker-buffer pom)))))
#+end_src

Sync the calendar each time we start Emacs, using the latest TLS version.

#+begin_src emacs-lisp
  (when (and org-caldav-url (not (equal org-caldav-url "")))
    (org-caldav-sync))
#+end_src


*** Tasks

A task should be in state =WAIT= when the task needs information from someone else; it should be
set to =HOLD= when I don't have time to do it.

Note that states =WAIT=, =HOLD=, and =DROP= request a note upon state shift.

#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
          (sequence "WAIT(w@/!)" "HOLD(h@/!)" "|" "DROP(c@/!)" "MEET")))
#+end_src

These colors work well with my theme of serenity.

#+begin_src emacs-lisp
  (setq org-todo-keyword-faces
        '(("TODO" :foreground "light salmon" :weight bold)
          ("NEXT" :foreground "SteelBlue1" :weight bold)
          ("DONE" :foreground "light green" :weight bold)
          ("WAIT" :foreground "MediumOrchid1" :weight bold)
          ("HOLD" :foreground "Orchid1" :weight bold)
          ("DROP" :foreground "VioletRed1" :weight bold)
          ("MEET" :foreground "light green" :weight bold)))
#+end_src

Let's add a time-created stamp to each task entry to match the closure stamp
that will be inserted. The helper function hooks into capture and the creation
of any new heading. When =M-RET= has been called with a prefix argument, the
property generation will be skipped.

#+begin_src emacs-lisp
  (require 'org-expiry)
  (setq org-expiry-created-property-name "CREATED"
        org-expiry-inactive-timestamps t)

  (defun npg/task-created-insert ()
    (unless current-prefix-arg
      (save-excursion
        (org-back-to-heading)
        (org-expiry-insert-created))))

  (add-hook 'org-capture-before-finalize-hook
            #'npg/task-created-insert)

  (add-hook 'org-insert-heading-hook
            #'npg/task-created-insert)
#+end_src

Since we have defined keys for each state, we can use fast selection with =C-c
C-t KEY=.

#+begin_src emacs-lisp
  (setq org-use-fast-todo-selection t)
#+end_src

Using =S-<arrow=, easily change task states without all the processing (e.g.
setting timestamps and notes) of normal state cycling. Useful for fixing the
status of an entry.

#+begin_src emacs-lisp
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+end_src

To aid agenda filtering, auto-update task tags whenever the state changes.

#+begin_src emacs-lisp
  (setq org-todo-state-tags-triggers
        (quote (("DROP" ("DROP" . t))
                ("WAIT" ("WAIT" . t))
                ("HOLD" ("WAIT") ("HOLD" . t))
                (done  ("WAIT") ("HOLD"))
                ("TODO" ("WAIT") ("DROP") ("HOLD"))
                ("NEXT" ("WAIT") ("DROP") ("HOLD"))
                ("DONE" ("WAIT") ("DROP") ("HOLD")))))
#+end_src

Always record the time that a task was archived.

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC


*** Journal

I think it is best to have lots of data split across many small Org files rather
than concentrated into a few huge ones. I developed =org-perspective= to largely
make this ambition practical. More specifically, I maintain a journal file for
each day, each of which is linked into a journal file that can also hold jots or
other scraps from any way.

I use this function to get today's journal file, to be used in the forthcoming
capture template listing. If the file doesn't exist, it is created according to specification.

#+begin_src emacs-lisp
  (defun npg/org-capture-journal (&optional date no-capture)
    (let* ((loc (op--physical-location "/Journal/Days"))
           (file (org-with-point-at loc
                  (org-persp-create-perspective
                   :spec (format-spec-make
                          ?d (format-time-string "%Y-%2m-%2d" date)
                          ?D (format-time-string "%Y-%2m-%2d %a" date)
                          ?A (file-name-as-directory (or (org-attach-dir) ""))
                          ?a user-full-name)
                   :force nil
                   :notes "%d.org"
                   :template "#+DATE: %d\n#+AUTHOR: %a"))))
      (set-buffer (org-cature-target-buffer file))
      file))
#+end_src

If I remember something I have written and want to read over it for a new
writing, I would like to search immediately within the current perspective.

#+begin_src emacs-lisp :tangle yes
  (defun npg/search-journal (string)
    (interactive (list (ag/read-from-minibuffer "Search")))
    (ag string (concat (org-persp-entry-point "/Personal/Jots" t) "days")))

#+end_src


*** Library

I would like to be able to capture books via ISBN.

#+begin_src emacs-lisp
  (defun npg/org-capture-isbn ()
    (let ((isbn (read-string "ISBN: "))
          (bibfile (completing-read "Bibfile: " (org-ref-possible-bibfiles))))
      (isbn-to-bibtex isbn bibfile :silent)
      (set-buffer (org-capture-target-buffer bibfile))))

  (defun npg/org-capture-bibtex ()
    (set-buffer (org-capture-target-buffer (completing-read "Bibfile: " (org-ref-possible-bibfiles)))))
#+end_src


*** Capture

Let's open =org-capture= in insert mode.
#+begin_src emacs-lisp
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+end_src

Define a few common tasks as capture templates.

For diversions, the idea is that I record all my notes in the day's journal file
and then later create a link or refile the subtree to the appropriate meetings
heading in the proper project.

#+begin_src emacs-lisp
  (setq org-capture-templates
        `(
          ("v" "Vocabulary")
          ("vr" "Russian vocabulary" entry
           (file+headline ,(org-persp-entry-point "/Vocabulary/Russian") "Vocabulary")
           "* %^{Word} :drill:\n %U\n** Definition \n%^{Definition}")
          ("ve" "English vocabulary" entry
           (file+headline ,(org-persp-entry-point "/Vocabulary/English") "Vocabulary")
           "* %^{Word} :drill:\n %U\n** Definition \n%^{Definition}")

          ("t" "Todo" entry (file+headline org-persp-index "INBOX")
           "* TODO %?\n%U\n" :clock-in t :clock-resume t)
          ("n" "Next" entry (file+headline org-persp-index "INBOX")
           "* NEXT %?\nDEADLINE: %t\n%U\n%a\n" :immediate-finish t)

          ("d" "Diversions")
          ("do" "Out" entry (function npg/org-capture-journal)
           "* %? :OUT:\n%U\n" :clock-in t :clock-resume t)
          ("dm" "Meeting" entry (function npg/org-capture-journal)
           "* %? :MEET:\n%U\n" :clock-in t :clock-resume t)

          ("f" "Financial transaction" plain
           (file "/home/npgentry/org/data/2f/54d8a1-2855-40d7-8baf-6fbe1ee0f9b3/2f54d8a1-2855-40d7-8baf-6fbe1ee0f9b3.ledger")
           "%(format-time-string \"%Y/%m/%d\") ! %?" :empty-lines 1)

          ("j" "Journal" entry (function npg/org-capture-journal)
           "\n\n* %U \n%?\n" :clock-in t :clock-resume t)

          ("l" "Library")
          ("lb" "BibTeX" plain (function npg/org-capture-bibtex)
           "@%? {\n}" :unnarrowed t :prepend t)
          ("li" "Book (ISBN)" plain (function npg/org-capture-isbn)
           nil :unnarrowed t :prepend t)))
#+end_src

While the following functionalities don't use =org-capture= per se, perhaps their best
place is here.

First, I want to create a new perspective with a LaTeX file properly placed for each
lecture in which I sit. These lectures will be auto-sequenced within the
appropriate notes file. For information on the =scribe= style used here, see my [[
https://github.com/npjg/tex-a-tac][tex-a-tac]] project.

#+begin_src emacs-lisp
  (defun npg/org-capture-lecture-1 (path subtree class &optional date)
    (org-with-point-at (op--physical-location (concat (file-name-as-directory path) subtree))
      (let ((parsed (org-element-parse-buffer)))
        (org-persp-launch nil (org-persp-create-perspective
         :spec (format-spec-make
                ?s subtree
                ?S class
                ?d (format-time-string "%Y-%2m-%2d" date)
                ?a (npg/org-buffer-prop "AUTHOR" nil parsed)
                ?c (npg/org-buffer-prop "COURSE" nil parsed)
                ?t (npg/org-buffer-prop "TERM" nil parsed)
                ?C (npg/org-buffer-prop "TITLE" nil parsed)
                ?i (or (org-entry-get nil "ITER" nil t) (progn (org-entry-put nil "ITER" "1") "1"))
                ?l (npg/org-buffer-prop "LECTOR" nil parsed))
         :force nil
         :subhead t
         :iter t
         :headline "%s %i"
         :notes "%C-%s%i.tex"
         :template "\\documentclass{%S}

  \\title{}
  \\author{%a}
  \\course{%c}
  \\term{%t}
  \\type{%s}
  \\period{%i}
  \\lector{%l}
  \\date{%d}

  \\begin{document}
  \\maketitle

  \\end{document}")))))

  (defun npg/org-capture-lecture (path)
    (interactive (list (op--prompt nil nil (op--enumerate-subtree "/Courses"))))
    (npg/org-capture-lecture-1 path "Lecture" "scribe"))

  (defun npg/org-capture-mission (path)
    (interactive (list (op--prompt nil nil (op--enumerate-subtree "/Courses"))))
    (npg/org-capture-lecture-1 path "Mission" "homework"))
#+end_src

I also want to capture new books with optional fulltexts into my library so I
can have a dedicated perspective for each one.


On launching a perspective from a headline, =org-perspective= attempts to find a
bookmark with the headline's ID. If it is found, this bookmark is opened in the
perspective. Thus, we easily implement a simple interface to PDF fulltexts,
=eww= buffers, or other ways to get the material we want.

#+begin_src emacs-lisp
  (setq library-bookmark-file
        (expand-file-name "library.bmkp"
                          (org-persp-entry-point
                           (plist-get npg/org-persp-important-paths :library)
                           :directory-only)))

  (defun npg/change-book-source (id source)
    (bmkp-switch-bookmark-file-create npg/library-bookmark-file)
    (org-open-link-from-string source)
    (with-current-buffer (window-buffer)
      (bookmark-set id))
    (bmkp-switch-to-last-bookmark-file))

  (defun npg/launch-book-with-source ()
    (let ((pom (point-marker))
          (id (org-id-get)))
      (org-persp-launch nil)
      (bookmark-jump-other-window id)))

#+end_src


*** Refile

Note that I have not yet tested refile functionality with the semantic paths of
=org-perspective=. We can refile into the current file and the index file, up to
3 levels deep.

#+begin_src emacs-lisp
  (setq org-refile-targets '((nil :maxlevel . 3)
                             (org-agenda-files :maxlevel . 3)))
#+end_src

Use full outline paths for refile targets, so ido works well.

#+begin_src emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+end_src

Allow =refile= to create parent nodes with confirmation.

#+begin_src emacs-lisp
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+end_src


*** Agenda

Some navigation functions, courtesy of Gregory Stein.

#+begin_src emacs-lisp
  (defun gs/org-agenda-next-section ()
    "Go to the next section in an org agenda buffer"
    (interactive)
    (if (search-forward "===" nil t 1)
        (forward-line 1)
      (goto-char (point-max)))
    (beginning-of-line))

  (defun gs/org-agenda-prev-section ()
    "Go to the next section in an org agenda buffer"
    (interactive)
    (forward-line -2)
    (if (search-forward "===" nil t -1)
        (forward-line 1)
      (goto-char (point-min))))
#+end_src

Make sure that we cannot mark a parent task done when child tasks are still
undone, and dim tasks that are so blocked.

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
  (setq org-agenda-dim-blocked-tasks nil)
#+end_src

Save all Org files whenever we refresh the agenda.

#+begin_src emacs-lisp
  (advice-add 'org-agenda-redo :after 'org-save-all-org-buffers)
#+end_src

Bury, do not kill, the agenda buffer on =q=. Also restore windows after we quit.
#+begin_src emacs-lisp
  (setq org-agenda-sticky t)
  (setq org-agenda-restore-windows-after-quit t)
#+end_src

Do not compact the block agenda view -- essential for our custom commands to
show correctly.
#+begin_src emacs-lisp
  (setq org-agenda-compact-blocks nil)
#+end_src

Set the times to display in the time grid.
#+begin_src emacs-lisp
  (setq org-agenda-time-grid
        (quote
         ((daily today remove-match)
          (800 1200 1600 2000)
          "......" "----------------")))
#+end_src

I don't have space here to reproduce the documentation here for the agenda
layout, but you can read that yourself, dear reader.

#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        '(
          (" " "Schedule"
           ((agenda "" ((org-agenda-overriding-header "Today's Schedule:")
                        (org-agenda-span 'day)
                        (org-agenda-ndays 1)
                        (org-agenda-start-on-weekday nil)
                        (org-agenda-start-day "+0d")
                        (org-agenda-todo-ignore-deadlines nil)))
            (tags-todo "INBOX" ((org-agenda-overriding-header "Inbox:")
                                (org-tags-match-list-sublevels nil)))
            (tags-todo "-WAIT-HOLD-DROP/!NEXT"
                       ((org-agenda-overriding-header "Next:")))
            (tags-todo "-WAIT-HOLD-DROP/!INBOX"
                       ((org-agenda-overriding-header "Active:")
                        (org-agenda-skip-function 'gs/select-projects)))
            (tags "ENDOFAGENDA"
                  ((org-agenda-overriding-header "")
                   (org-tags-match-list-sublevels nil))))
           ((org-agenda-start-with-log-mode t)
            (org-agenda-log-mode-items '(clock))
            (org-agenda-prefix-format
             '((agenda . " %-12:c%?-12t %(gs/org-agenda-add-location-string)% s")
               (timeline . "  % s")
               (todo . " %(npg/org-agenda-prefix-string) ")
               (tags . " %(npg/org-agenda-prefix-string) ")
               (search . "  %i %-12:c")))
            (org-agenda-todo-ignore-deadlines 'near)
            (org-agenda-todo-ignore-scheduled t)))

          ("a" "Agenda"
           ((agenda "") (alltodo))
           ((org-agenda-ndays 10)
            (org-agenda-start-on-weekday nil)
            (org-agenda-start-day "-1d")
            (org-agenda-start-with-log-mode t)
            (org-agenda-log-mode-items '(closed clock state))))))
#+end_src

Here are the helper functions referenced in the preceding.

#+begin_src emacs-lisp
  (defun npg/org-agenda-prefix-string ()
    "Format"
    (let ((path (org-format-outline-path (org-get-outline-path))) ; "breadcrumb" path
          (stuck nil)) ;;(gs/org-agenda-project-warning))) ; warning for stuck projects
      (if (> (length path) 0)
          (concat stuck ; add stuck warning
                  " [" path "]") ; add "breadcrumb"
        stuck)))

  (defun gs/org-agenda-add-location-string ()
    "Gets the value of the LOCATION property"
    (let ((loc (org-entry-get (point) "LOCATION")))
      (if (> (length loc) 0)
          (concat "{" loc "} ")
        "")))
#+end_src

When we narrow to a subtree, either from an Org file or in the agenda, the Org
file should be narrowed /and/ the agenda restriction lock should be set.

#+begin_src emacs-lisp
  (defun bh/narrow-to-org-subtree ()
    (widen)
    (org-narrow-to-subtree)
    (save-restriction
      (org-agenda-set-restriction-lock)))

  (defun bh/narrow-to-subtree ()
    (interactive)
    (if (equal major-mode 'org-agenda-mode)
        (progn
          (org-with-point-at (org-get-at-bol 'org-hd-marker)
            (bh/narrow-to-org-subtree))
          (when org-agenda-sticky
            (org-agenda-redo)))
      (bh/narrow-to-org-subtree)))
#+end_src

Let's provide a similar correspondence for mowing the narrow up one headline level.

#+begin_src emacs-lisp
  (defun bh/narrow-up-one-org-level ()
    (widen)
    (save-excursion
      (outline-up-heading 1 'invisible-ok)
      (bh/narrow-to-org-subtree)))

  (defun bh/get-pom-from-agenda-restriction-or-point ()
    (or (and (marker-position org-agenda-restrict-begin) org-agenda-restrict-begin)
        (org-get-at-bol 'org-hd-marker)
        (and (equal major-mode 'org-mode) (point))
        org-clock-marker))

  (defun bh/narrow-up-one-level ()
    (interactive)
    (if (equal major-mode 'org-agenda-mode)
        (progn
          (org-with-point-at (bh/get-pom-from-agenda-restriction-or-point)
            (bh/narrow-up-one-org-level))
          (org-agenda-redo))
      (bh/narrow-up-one-org-level)))

#+end_src

Finally, let's remove empty agenda blocks from the display.

#+begin_src emacs-lisp
  (defun gs/remove-agenda-regions ()
    (save-excursion
      (goto-char (point-min))
      (let ((region-large t))
        (while (and (< (point) (point-max)) region-large)
          (set-mark (point))
          (gs/org-agenda-next-section)
          (if (< (- (region-end) (region-beginning)) 5) (setq region-large nil)
            (if (< (count-lines (region-beginning) (region-end)) 4)
                (delete-region (region-beginning) (region-end))))))))

  (add-hook 'org-agenda-finalize-hook 'gs/remove-agenda-regions)
#+end_src


*** Clock

Let's keep clock records in a =LOGBOOK= drawer by default.

#+begin_src emacs-lisp
  (setq org-drawers (quote ("PROPERTIES" "LOGBOOK"))
        org-clock-into-drawer t)
#+end_src

I only want to see the time clocked for the current instance; if I want to see
more time, I can just jump to the Org file. I want the current clock to have
relevance to keep me on track as I work, and it is hard to do that when I forget
at what time the clock started.

#+begin_src emacs-lisp
  (setq org-clock-mode-line-total 'current)
#+end_src

Since I change tasks often -- especially when I quickly capture something -- I
don't want a bunch of zero-duration clock records in the logbooks.

#+begin_src emacs-lisp
  (setq org-clock-out-remove-zero-time-clocks t)
#+end_src

I don't want the clock to distract me, so I will set a fairly grainy clock
resolution of 5 minutes.

#+begin_src emacs-lisp
  (setq org-clock-rounding-minutes 5)
#+end_src

I use continuous clocking, whereby a clock always runs somewhere when I am
punched in. A default organization task, defined in =org-persp-index=, gives the
default headline that accumulates time when no other task is active.

#+begin_src emacs-lisp
  (defvar bh/organization-task-id "eb155a82-92b2-4f25-a3c6-0304591af2f9")
#+end_src

With this, we can define continuous clocking.

#+begin_src emacs-lisp
  (defvar bh/keep-clock-running nil
    "Indicate whether or not continuous clocking has been enabled.")

  (defun bh/clock-in-organization-task-as-default ()
    (interactive)
    (org-with-point-at (org-id-find bh/organization-task-id 'marker)
      (org-clock-in '(16))))

  (defun bh/punch-in (arg)
    "Start continuous clocking on the default task."
    (interactive "p")
    (setq bh/keep-clock-running t)
    (bh/clock-in-organization-task-as-default))

  (defun bh/punch-out ()
    (interactive)
    (setq bh/keep-clock-running nil)
    (when (org-clock-is-active)
      (org-clock-out)))
#+end_src

It would be nice to have a way to move up the project tree.

#+begin_src emacs-lisp
  (defun bh/clock-in-parent-task ()
    "Move point to the parent (project) task if any and clock in"
    (let ((parent-task))
      (save-excursion
        (save-restriction
          (widen)
          (while (and (not parent-task) (org-up-heading-safe))
            (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
              (setq parent-task (point))))
          (if parent-task
              (org-with-point-at parent-task
                (org-clock-in))
            (when bh/keep-clock-running
              (bh/clock-in-default-task)))))))

  (defun bh/clock-out-maybe ()
    "Clock into the parent task only when it makes sense to do so."
    (when (and bh/keep-clock-running
               (not org-clock-clocking-in)
               (marker-buffer org-clock-default-task)
               (not org-clock-resolving-clocks-due-to-idleness))
      (bh/clock-in-parent-task)))

  (add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)
#+end_src

To create an effort estimate for a task or subtree, start column mode with =C-c
C-x C-c= and collapse the tree with =c=. With the point on the =Effort= column,
set the estimated effort with the numeric keys, corresponding to the time values
below.

#+begin_src emacs-lisp
  (setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                      ("STYLE_ALL" . "habit"))))
#+end_src

To read more about these simple settings, just do =C-h v= on each name.

#+begin_src emacs-lisp
  (setq org-clock-in-resume t
        org-clock-persist t
        org-clock-in-resume t
        org-clock-persist-query-resume nil
        org-clock-auto-clock-resolution 'when-no-clock-is-running
        org-clock-out-when-done t
        org-clock-report-include-clocking-task t)

#+end_src

Quickly mark the currently clocked task as DONE.

#+begin_src emacs-lisp
  (defun npg/mark-clocked-task-done ()
    (interactive)
    "Mark the currently clocked task DONE."
    (org-clock-out "DONE"))
#+end_src

We can see a summary of clocking data in a column view. Let's set
=org-column-view= (=C-c C-x C-c=) to emphasize timekeeping: [Task] [Effort]
[ClockSummary].

#+begin_src emacs-lisp
  (setq org-columns-default-format "%32ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM %16TIMESTAMP_IA")
#+end_src


*** Attachments

I don't like autotagging when I have attachments on a task.

#+begin_src emacs-lisp
  (setq org-attach-auto-tag nil)
#+end_src


The newest version of =org-mode= seems to have removed the entrywise inheritance
for attachment directories, so let's just enable this inheritance globally.
This will help with keeping lectures and such in the right place in my ID-driven
hierarchy.

#+begin_src emacs-lisp
  (setq org-attach-use-inheritance t)
#+end_src


*** Drill

I use =org-drill= to maintain my vocabulary lists.

#+begin_src emacs-lisp
  (use-package org-drill
    :after org
    :config (progn
              (add-to-list 'org-modules 'org-drill)
              (setq org-drill-add-random-noise-to-intervals-p t)
              (setq org-drill-hint-separator "||")
              (setq org-drill-left-cloze-delimiter "<[")
              (setq org-drill-right-cloze-delimiter "]>")
              (setq org-drill-learn-fraction 0.25)
              (setq org-drill--lapse-very-overdue-entries-p t)))
#+end_src


* Fine

Since all subtree files have IDs in my system, and I want to find tasks wherever
they are, we can piggy-back from the ID subsystem.

#+begin_src emacs-lisp
  (require 'org-id)
  (setq org-agenda-files org-id-files)
#+end_src

We have only to define what the user should first see on opening Emacs.

#+begin_src emacs-lisp
  (find-file org-persp-index)
  (org-agenda nil " ")

#+end_src

And so, dear reader, this is my Emacs philosophy. It is forever in flux; you
never run the same configuration once. May the parentheses be with you.
